== BaseX-based test suites

=== Required knowledge
To develop Executable Test Suites for testing XML documents in ETF using BaseX,
you should be familiar with:

* link:http://www.w3.org/TR/xquery-31/[XQuery] and XML technologies in general
* the ETF domain model items
** link:http://resources.etf-validator.net/schema/v2/doc/test_xsd.html#ExecutableTestSuite[ Executable Test Suite]
** link:http://resources.etf-validator.net/schema/v2/doc/capabilities_xsd.html#TestObject[Test Object]
** link:http://resources.etf-validator.net/schema/v2/doc/run_xsd.html#TestTask[Test Task]
** link:http://resources.etf-validator.net/schema/v2/doc/result_xsd.html#TestTaskResult[Test Task Result]

include::BaseX_ETS_GUI.adoc[]

=== Basics

In ETF, sets of XML documents are tested using link:http://basex.org[BaseX], an XML database.
An Executable Test Suite is essentially an link:http://www.w3.org/TR/xquery-31/[XQuery] that operates on the set of XML documents under test and returns an XML document with the root element `etf:TestTaskResult`.

The content model is specified using an link:http://resources.etf-validator.net/schema/v2/doc/service.html[XML schema].

The current stable schema is available link:http://resources.etf-validator.net/schema/v2/service/service.xsd[here] and can be used for validating ETF XML structures:

[source,XML]
----
<EtfModelItem xmlns="http://www.interactive-instruments.de/etf/2.0"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.interactive-instruments.de/etf/2.0 http://resources.etf-validator.net/schema/v2/service/service.xsd" ...>
  ...
</EtfModelItem>
----

Here is a simple example with one test case result embedding two test assertions results:

.Simple example of the result of testing a BaseX-based Executable Test Suite
=====================================================================
[source,XML]
----
<TestTaskResult xmlns="http://www.interactive-instruments.de/etf/2.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.interactive-instruments.de/etf/2.0 http://resources.etf-validator.net/schema/v2/service/service.xsd"
    id="EIDc5e50620-5107-4b75-b6c1-74d4465fba0f">
    <testObject ref="EID666f71c1-9af3-4040-a21d-190f953725f4"/>
    <testModuleResults>
        <TestModuleResult id="EIDfdfc25d5-1790-43bd-abb6-2de6263619cc">
            <testCaseResults>
                <TestCaseResult id="EID3dab6279-f553-4f93-b1bc-b73329fc69c3">
                    <testStepResults>
                        <TestStepResult id="EIDffaf6f6a-66f6-4796-8c42-e5f681517c62">
                            <testAssertionResults>
                                <TestAssertionResult id="EIDa35d1dd3-7cc2-41c7-9b2b-f60df48ffabb">
                                    <parent ref="EIDffaf6f6a-66f6-4796-8c42-e5f681517c62"/>
                                    <resultedFrom ref="EIDcab35f1a-6292-44b9-ae2c-9ec62fc0f4b6"/>
                                    <startTimestamp>2016-09-05T13:10:24Z</startTimestamp>
                                    <duration>0</duration>
                                    <status>PASSED</status>
                                </TestAssertionResult>
                                <TestAssertionResult id="EIDc18b01ff-f544-4d0e-9a8f-ef3874abd43f">
                                    <messages>
                                        <message ref="TR.filesWithErrors">
                                            <translationArguments>
                                                <argument token="count">1</argument>
                                            </translationArguments>
                                        </message>
                                        <message ref="TR.incorrectRoot">
                                            <translationArguments>
                                                <argument token="filename">ps-root.xml</argument>
                                                <argument token="elementName">FeatureCollection</argument>
                                                <argument token="namespace">http://www.opengis.net/wfs</argument>
                                            </translationArguments>
                                        </message>
                                    </messages>
                                    <parent ref="EIDffaf6f6a-66f6-4796-8c42-e5f681517c62"/>
                                    <resultedFrom ref="EID928d8204-3015-4811-82fd-f4779b35385b"/>
                                    <startTimestamp>2016-09-05T13:10:24Z</startTimestamp>
                                    <duration>1</duration>
                                    <status>FAILED</status>
                                </TestAssertionResult>
                            </testAssertionResults>
                            <parent ref="EID3dab6279-f553-4f93-b1bc-b73329fc69c3"/>
                            <resultedFrom ref="EIDc177cf64-3a66-4ac4-92b9-61207aab8007"/>
                            <startTimestamp>2016-09-05T13:10:24Z</startTimestamp>
                            <duration>1</duration>
                            <status>FAILED</status>
                        </TestStepResult>
                    </testStepResults>
                    <parent ref="EIDfdfc25d5-1790-43bd-abb6-2de6263619cc"/>
                    <resultedFrom ref="EIDf66872d4-3a1f-4581-a501-94200219bf13"/>
                    <startTimestamp>2016-09-05T13:10:24Z</startTimestamp>
                    <duration>1</duration>
                    <status>FAILED</status>
                </TestCaseResult>
            </testCaseResults>
            <parent ref="EIDc5e50620-5107-4b75-b6c1-74d4465fba0f"/>
            <resultedFrom ref="EID8e96257c-ae42-4123-b298-b8c5eda3a027"/>
            <startTimestamp>2016-09-05T13:10:24Z</startTimestamp>
            <duration>1</duration>
            <status>FAILED</status>
        </TestModuleResult>
    </testModuleResults>
    <attachments>
        <Attachment id="EIDc5e50620-5111-4bc5-b6c1-74d4465fbb23">
            <label>Log file</label>
            <encoding>UTF-8</encoding>
            <mimeType>text/plain</mimeType>
            <referencedData href="file://local/log.txt"/>
        </Attachment>
    </attachments>
    <resultedFrom ref="EID545f9e49-009b-4114-9333-7ca26413b5d4"/>
    <startTimestamp>2016-09-05T13:10:24Z</startTimestamp>
    <duration>1</duration>
    <status>FAILED</status>
</TestTaskResult>
----
=====================================================================


The document is based on the nested structures of test modules, test
cases, test steps and test assertions. For each of these result items
some basic information is provided:

* An identifier in an attribute `id`. The value must be a UUID with a
prefix "EID", e.g. "EIDc5e50620-5107-4b75-b6c1-74d4465fba0f".
+
In XQueries in BaseX, new UUID values can be created using
`uuid:randomUUID()` where the uuid namespace is declared using
`declare namespace uuid='java.util.UUID';`.
* Each result item, except the top level test task result (representing
the result of executing the test suite) has a `etf:parent` child element
with a `ref` attribute. The value of the `ref` attribute is the `id` of
the ancestor result item.
+
NOTE: In this packaging of the result items the `ref` value is redundant
as it could be derived from the nested document structure, but it is
required so that the result items can also be stored separately without
losing the relationships between the result items.
* The status of the result item is given in a child element
`etf:status`. For every level except the lowest level (the test
assertions), the status must be derived automatically from the status
values of the next lower level where the following XQuery function could
be used (`$statusValues` is the sequence of status values from the lower
level result items):
+
[source,XQUERY]
--------------------------------------------------------------------------
declare function local:status($statusValues as xs:string*) as xs:string
{
    if ($statusValues ='FAILED') then 'FAILED'
    else if ($statusValues ='SKIPPED') then 'SKIPPED'
    else if ($statusValues ='WARNING') then 'WARNING'
    else if ($statusValues ='INFO') then 'INFO'
    else if ($statusValues ='PASSED_MANUAL') then 'PASSED_MANUAL'
    else if ($statusValues ='PASSED') then 'PASSED'
    else if ($statusValues ='NOT_APPLICABLE') then 'NOT_APPLICABLE'
    else 'UNDEFINED'
};
--------------------------------------------------------------------------
* A time stamp when the execution of the test item was started in child
element `etf:startTimestamp`. The value is expected to include seconds
and be in the UTC timezone.
* The duration of the execution in milliseconds (an integer) in child
element `etf:duration`.
* A reference to the corresponding test item for which this is a result
is included in attribute `ref` in child element `etf:resultedFrom`.
Again, `ref` is the id of that test item. An `etf:TestAssertionResult`
will always reference an `etf: TestAssertion`, and so on. The test items
and their XML representation are discussed below.

The `etf:TestTaskResult` may have additional child elements (more
information is provided in separate pages documenting more advanced
features), but it must have a child element `etf:testObject` that
references the `etf:TestObject` that represents the XML documents under
test. As this identifier is assigned by ETF, it is passed to the XQuery
as an external variable `$testObjectId`.

Test assertions may include messages. This is at least the case for
failed assertions or assertions with warnings or other information.
These are provided embedded in a child element `etf:messages` where each
message has the following structure (to support translation of messages
into different languages:

* A `ref` attribute that includes the name of a message template. All
template names start with "TR.". Message templates and their XML
representation are discussed below. They are basically a set of text
strings (one for each supported language) which include placeholders.
* For each of the placeholders an `etf:argument` element is provided
inside of an `etf:translationArgument` element. The `token` attribute is
the name of the placeholder and the text node is the value the
placeholder should be replace with in the message.

[[typical-setup]]
Typical setup
~~~~~~~~~~~~~

The BaseX test driver in ETF expects that each Executable Test Suite is
specified using an XML document described in the next section. The
document includes a file reference to the XQuery to be executed. The
BaseX test driver of ETF will execute this XQuery and pass the file
reference to the Executable Test Suite document in an external variable
`$etsFile`.

The XQuery will process the Executable Test Suite document and execute
each test assertion and return the XML document with the root element
`etf:TestTaskResult` as described above.

The details are discussed in the following sections.

[[xml-document-of-an-executable-test-suite]]
XML document of an Executable Test Suite
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A document specifying an Executable Test Suite is an XML document with
the root element `etf:ExecutableTestSuite`. The content model is
specified using an
https://github.com/interactive-instruments/etf-bsxds/blob/master/src/main/resources/schema/model/test.xsd[XML
schema].

In order to enable that ETF can identify all Executable Test Suite
documents (and monitor them for changes) without analysing the file
content, the file names have to use a suffix "-bsxets.xml".

Here is a simple example:

.A simple BaseX-based Executable Test Suite
=====================================================================
[source,XML]
----
<?xml version="1.0" encoding="utf-8"?>
<ExecutableTestSuite xmlns="http://www.interactive-instruments.de/etf/2.0"     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.interactive-instruments.de/etf/2.0 https://resources.etf-validator.net/schema/v2/val/ignoreRef.xsd" id="EID545f9e49-009b-4114-9333-7ca26413b5d4">
    <itemHash>bQ==</itemHash>
    <remoteResource>http://github.com/inspire-eu-validation/ets-repository/data-encoding/inspire-gml</remoteResource>
    <localPath>/auto</localPath>
    <label>Conformance class: INSPIRE GML encoding</label>
    <description><![CDATA[This test suite examines GML documents against basic requirements for the GML encoding for spatial data sets in INSPIRE. This only covers application-schema-independent, generic requirements. Requirements related to specific application schemas are part of conformance classes with a dependency on this conformance class.<br/><br/>
<b>This is a draft version. It has limitations and is expected to contain errors.</b> Please report any issues or problems <a href="https://github.com/interactive-instruments/ets-repository/issues" target="_blank">in GitHub</a>.<br/><br/>
Known limitations are documented in the description of the applicable test case or test assertion.<br/><br/>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-encoding/3.3/inspire-gml" target="_blank">Conformance Class 'INSPIRE GML encoding'</a><br/><br/>
Pre-requisite conformance classes:
<ul><li>Conformance Class 'GML 3.2 documents [OGC]'</li></ul>]]></description>
    <reference>../../inspire-bsxets.xq</reference>
    <version>0.1.0</version>
    <author>interactive instruments GmbH</author>
    <creationDate>2016-08-15T00:00:00Z</creationDate>
    <lastEditor>interactive instruments GmbH</lastEditor>
    <lastUpdateDate>2016-08-15T00:00:00Z</lastUpdateDate>
    <testDriver ref="EID4dddc9e2-1b21-40b7-af70-6a2d156ad130"/>
    <translationTemplateBundle ref="EID70a263c0-0ad7-42f2-9d4d-0d8a4ca71b52"/>
    <supportedTestObjectTypes>
        <testObjectType ref="EIDe1d4a306-7a78-4a3b-ae2d-cf5f0810853e"/>
    </supportedTestObjectTypes>
    <testModules>
        <TestModule id="EID8e96257c-ae42-4123-b298-b8c5eda3a027">
            <label>IGNORE</label>
            <description>IGNORE</description>
            <parent ref="EID545f9e49-009b-4114-9333-7ca26413b5d4"/>
            <testCases>
                <TestCase id="EIDf66872d4-3a1f-4581-a501-94200219bf13">
                    <label>Basic tests</label>
                    <description>Verify that all documents contain GML features and use the expected character encoding.</description>
                    <parent ref="EID8e96257c-ae42-4123-b298-b8c5eda3a027"/>
                    <testSteps>
                        <TestStep id="EIDc177cf64-3a66-4ac4-92b9-61207aab8007">
                            <label>IGNORE</label>
                            <description>IGNORE</description>
                            <parent ref="EIDf66872d4-3a1f-4581-a501-94200219bf13"/>
                            <statementForExecution>not applicable</statementForExecution>
                            <testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
                            <testAssertions>
                                <TestAssertion id="EIDcab35f1a-6292-44b9-ae2c-9ec62fc0f4b6">
                                    <label>gml.a.1: Errors loading the XML documents</label>
                                    <description><![CDATA[Report errors that occurred during loading the documents in the test object. A typical example is an XML document that is not well-formed and therefore cannot be processed.]]></description>
                                    <parent ref="EIDc177cf64-3a66-4ac4-92b9-61207aab8007"/>
                                    <expectedResult>NOT_APPLICABLE</expectedResult>
                                    <expression>if (not($validationErrors)) then 'PASSED' else ('FAILED', for $error in $validationErrors return (local:addMessage('TR.valdiationError', map { 'text': $error })))</expression>
                                    <testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
                                    <translationTemplates>
                                        <translationTemplate ref="TR.valdiationError"/>
                                    </translationTemplates>
                                </TestAssertion>
                                <TestAssertion id="EID928d8204-3015-4811-82fd-f4779b35385b">
                                    <label>gml.a.2: Document root element</label>
                                    <description><![CDATA[Check for each XML document that the root element is a GML feature or a GML feature collection.<br/><br/>
For feature collections the following root elements are recognised:
<ul>
<li>wfs:FeatureCollection (WFS 2.0),</li>
<li>gml:FeatureCollection (GML 3.2),</li>
<li>base:SpatialDataSet (INSPIRE Base 3.2 or 3.3).</li>
</ul>
This test is a pre-condition to identify the INSPIRE features in the test object.<br/><br/>
Relevant requirements and recommendations:
<ul><li>Recommendation 11 - For the exchange of spatial objects in GML, an XML document with a FeatureCollection root element from ISO 19142:2010 (WFS 2.0) should be used.</li></ul>
<b>Known limitations:</b>
<ul>
<li>Currently only feature collections are recognized as the test engine BaseX is not schema-aware. A new extension function is required to identify all feature elements.</li>
</ul>
Source: <a href="" target="_blank">Abstract Test Case 'Basic test'</a>]]></description>
                                    <parent ref="EIDc177cf64-3a66-4ac4-92b9-61207aab8007"/>
                                    <expectedResult>NOT_APPLICABLE</expectedResult>
                                    <expression>
let $filesWithErrors := $db[not(wfs:FeatureCollection or gml:FeatureCollection or base32:SpatialDataSet or base:SpatialDataSet or gml:AbstractFeature)][position() le $limitErrors]
return
(if ($filesWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.filesWithErrors', count($filesWithErrors)),
 for $file in $filesWithErrors
    order by local:filename($file)
    let $root := $file/element()
    return
    local:addMessage('TR.incorrectRoot', map { 'filename': local:filename($root), 'elementName': local-name($root), 'namespace': namespace-uri($root) }))
                                    </expression>
                                    <testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
                                    <translationTemplates>
                                        <translationTemplate ref="TR.incorrectRoot"/>
                                        <translationTemplate ref="TR.filesWithErrors"/>
                                    </translationTemplates>
                                </TestAssertion>
                            </testAssertions>
                        </TestStep>
                    </testSteps>
                </TestCase>
            </testCases>
        </TestModule>
    </testModules>
</ExecutableTestSuite>
----
=====================================================================

Let's go through the document in the example in detail:

* All items that are stored by ETF and may be referenced include an
attribute `id` where the value must be a UUID with a prefix "EID". There
are many ways to generate a pool of UUIDs when drafting an Executable
Test Suite, including web sites like https://www.uuidgenerator.net/. +
* All items include the properties `etf:label` and `etf:description`. It
is essential to provide these elements in order to generate test reports
that are useful and understandable. The description may include HTML
markup that will be used when generating test reports in HTML; the
markup must encoded or embedded in a CDATA section.
* All items, except the top level test suite, has a `etf:parent` child
element with a `ref` attribute. The value of the `ref` attribute is the
`id` of the ancestor item. Like in the case of the test result in the
section "Introduction", the `ref` value is redundant as it could be
derived from the nested document structure, but it is required so that
the items can also be handled separately within ETF without losing the
relationships between the items.
* The elements `etf:itemHash` and `etf:localPath` are used by ETF
internally. Use "bQ==" and "/auto" as initial values respectively.
* The element `etf:remoteResource` may be included to provide a link to
a webpage where additional information about the test suite can be
found.
* The element `etf:reference` is a local file reference to
link:#the-xquery-document[the XQuery] to be executed by the ETF test
driver for BaseX.
* The elements `etf:version`, `etf:author`, `etf:creationDate`,
`etf:lastEditor` and `etf:lastUpdateDate` are used to provide metadata
about this version of the Executable Test Suite. The 'date' values are
expected to include time and be in the UTC timezone.
* The element `etf:testDriver` references the test driver for BaseX. The
current test driver has a fixed identifier
"EID4dddc9e2-1b21-40b7-af70-6a2d156ad130".
* The element `etf:translationTemplateBundle` references an
`etf:TranslationTemplateBundle` object containing all linguistic text in
one or more languages used in an Executable Test Suite. The structure of
the document is described below. Multiple Executable Test Suites may
share a single bundle. A bundle is typically managed as a separate XML
document located the sub directory `include-metadata`.
* The element `etf:supportedTestObjectTypes` includes references to the
`etf:TestObjectType`s that this Executable Test Suite supports, i.e. the
Executable Test Suite can be executed on test objects that are of one
the referenced types. For each supported `etf:TestObjectType` an element
`etf:testObjectType` is created.
* Test modules, test cases, test steps and test assertions are described
in the document where the nesting represents the structure of the test
items. The example above has a single test module with a single test
case with a single test step and two test assertions.
* For BaseX tests the concept of test steps is usually not applicable
and there will be exactly one test step for each test case. If label and
description of the test step are set to the values "IGNORE" the
superfluous test step will not be shown in test reports.
* Often the additional structure level of test modules is not needed or
used, i.e. there will be exactly one test module in the test suite.
Again, if label and description of the test module are set to the values
"IGNORE" the superfluous test module will not be shown in test reports.
* The elements `etf:statementForExecution` and `etf:testItemType` in
test steps are not relevant for tests using BaseX, but must be provided.
`etf:statementForExecution` must be a value that is not empty; a typical
approach is to use "not applicable" as the value. For
`etf:testItemType`, reference "EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0",
which is a pre-defined `etf:TestItemType` for superfluous test steps in
BaseX.
* For test assertions the elements discussed in the next bullet items
need to be provided.
* The element `etf:expectedResult` is not relevant for tests using
BaseX, but must be provided. Use "NOT_APPLICABLE" as the value.
* The element `etf:testItemType` identifies the type of the test
assertion. Three values are pre-defined for BaseX tests:
* "EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a" for assertions where the
element `etf:expression` contains an XQuery fragment that has to be
executed to determine the result.
* "EIDb48eeaa3-6a74-414a-879c-1dc708017e11" for assertions where the
element `etf:expression` can be ignored and the result status will
always be 'PASSED_MANUAL' indicating that the assertion needs to be
checked manually by an expert.
* "EID92f22a19-2ec2-43f0-8971-c2da3eaafcd2" for assertions that are
disabled, e.g. during the drafting phase or due to known issues that
have to be fixed.
* In case of an assertion of type
"EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a", the element `etf:expression`
contains an XQuery fragment that will be executed to determine the
result and any messages for the user. The rules for these expressions
are discussed in the next section about the XQuery document.
* The element `etf:translationTemplates` lists all message templates
that may be created by the test assertion as part of the execution of
the XQuery fragment.

[[the-xquery-document]]
The XQuery document
~~~~~~~~~~~~~~~~~~~

As explained in the sections above, the XQuery has to process the
`etf:ExecutableTestSuite` document, execute queries based on the
expressions for each XQuery assertion and return a `etf:TestTaskResult`
document capturing the result of the test execution.

The ETF test driver for BaseX passes the following external variables to
the XQuery, which must be declared in the XQuery and which are necessary
to enable the execution of the test suite:

* `$testObjectId` is the id of the test object on which the test suite
is to be executed. This information is required to construct the
`etf:TestTaskResult` document.
* `$testTaskResultId` is the id of the result, i.e. the
`etf:TestTaskResult` element.
* `etf:$projDir` is the local path to the project directory that is
monitored by ETF and which contains all necessary files including the
`etf:ExecutableTestSuite` document, the XQuery document, the
`etf:TranslationTemplateBundle` document, etc.
* `etf:$tmpDir` is the local path to a directory where additional files
may be written during execution. This is discussed in the section on
attachements below.
* ETF loads all XML documents under test into one or more BaseX
databases. Typically it will be one database, but for very large sets of
XML documents the documents will distributed into several databases due
to limitations in the number of XML nodes per database. In this case,
the name of the databases will follow the pattern
`concat($dbBaseName,'-',$i)` where `$i` is an integer between `0` and
`$dbCount-1`.
* `$etsFile` is the local path to the XML document of the Executable
Test Suite to be executed.
* `$validationErrors` is a string with any errors that occured during
loading the XML documents under test into BaseX. Only documents with
file extensions "xml" and "gml" are processed. Files that are not
well-formed XML documents are excluded. If schema validation against a
pre-defined schema is activated, only valid schemas are loaded. Any
errors detected in the files by the XML parser are reported in this
variable. This information may be used in a test assertion.

How the XQuery processes the `etf:ExecutableTestSuite` document,
executes queries for each XQuery assertion and generates the
`etf:TestTaskResult` document is up to the developer of the Executable
Test Suite, but the standard approach is the following:

* The values of the variables are checked. In case of an error an
exception is raised.
* The database(s) are opened.
* The items to inspect, e.g. the elements representing GML features, are
identified.
* The Executable Test Suite document `$etsFile` is loaded.
* A single XQuery that will execute the complete test suite using the
eval() function of XQuery is compiled. This approach is necessary as the
XQuery fragments in the `etf:expression` elements in the test assertions
need to be executed. This single XQuery consists of a fixed prolog
consisting of
* namespace / module / variable declarations and functions used in
`etf:expression` elements (this typically is read from a separate file),
* additional preparatory statements and
* the `etf:TestTaskResult` XML structure based on the test modules, test
cases, test step and test assertions in the Executable Test Suite
document.
* Try/catch blocks are used frequently to contain error situations as
good as possible, including errors in the XQuery fragments in
`etf:expression` elements.
* This XQuery is executed using eval() and the result is returned to the
ETF test driver.

TIP: A generic template for reuse is available in the
https://github.com/interactive-instruments/etf-ets-repository/tree/master/generic[directory
'generic'].

This generic template is designed for testing features
(however, the basic structure is the same, if metadata records or other
XML elements are subject to the tests). The generic template consists of

* a
https://github.com/interactive-instruments/etf-ets-repository/blob/master/generic/ets-generic-bsxets.xq[generic
XQuery],
* a
https://github.com/interactive-instruments/etf-ets-repository/blob/master/generic/generic-query-prolog.xq[generic
XQuery prolog] for the dynamic XQuery that is compiled by
ets-generic-bsxets.xq,
* additional preparatory statements that add a statistics table with the
number of features per feature type is adds features with geometries to
a spatial index to support spatial queries in assertions using the
https://github.com/interactive-instruments/etf-gmlgeox[GmlGeoX module]),
* a
https://github.com/interactive-instruments/etf-ets-repository/blob/master/generic/include-metadata/generic-ettb.xml[starting
point for a translation template bundle] and
* a
https://github.com/interactive-instruments/etf-ets-repository/blob/master/generic/include-metadata/generic-esrtt.xml[statistical
table template].

In this generic XQuery, the following variables are passed to the
dynamic XQuery, i.e. these variables are available in the
`etf:expression` fragments:

* `$db`: the sequence of XML document nodes of the XML documents under
test
* `$features`: the sequence of GML feature elements in the XML documents
under test
* `$idMap`: a map of the gml:id values of the features
* `$testObjectId`: the id of the test object in ETF
* `$logFile`: the name of the log file in the tmp directory
* `$statFile`: the name of the file with the statistical table in the
tmp directory
* `$limitErrors`: to avoid memory and runtime issues in cases with
millions of errors it is recommended to limit the number of errors that
is processed for each assertion; by default '1000' is used
* `$validationErrors`: the list of errors that occured when loading the
XML documents under test into the BaseX databases

Currently the XQuery fragment in an `etf:expression` in each assertion
has to return a sequence of items, where the first item is a string with
the status, e.g. 'PASSED' or 'FAILED'. Any additional items must be
`etf:message` elements.

.XQueries used in the INSPIRE validator
======================================
In the INSPIRE case, there are three different XQuery options that are
used. In Exectuable Test Suites that

* ... test features (elements
substitutable for gml:AbstractFeature) and which include tests calling
functions of the GmlGeoX library,
https://github.com/inspire-eu-validation/ets-repository/blob/master/inspire-bsxets.xq[inspire-bsxets.xq] is used;
* ... test features (elements substitutable for gml:AbstractFeature),
but without using the GmlGeoX library,
https://github.com/inspire-eu-validation/ets-repository/blob/master/inspire-noggeo-bsxets.xq[inspire-noggeo-bsxets.xq] is used;
* ... test metadata records (gmd:MD_Metadata),
https://github.com/inspire-eu-validation/ets-repository/blob/master/inspire-md-bsxets.xq[inspire-md-bsxets.xq] is used.
======================================

[NOTE]
======================================
The current mechanism will in the future be replaced by a new BaseX
module implementing a listener similar to the following XQuery functions
currently defined in generic-query-prolog.xq:

* `start($id as xs:string) as empty-sequence()`
* `end($id as xs:string, $status as xs:string) as empty-sequence()`
* `addMessage($templateId as xs:string, $map as map(*)) as element()
* `log($text as xs:string) as empty-sequence()`

Once the listener is implemented, the whole generation of the
`etf:TestTaskResult` document will be done by the ETF test driver.
======================================

[[the-prepare-chunk-document]]
=== The prepare-chunk document
A prepare-chunk.xq document is optional but can be used to preprocess testdata.

Example usage: Prepare a spatial index and extract all objects with erroneous geometry before executing the tests.
[NOTE]
======================================
* For every given chunk, prepare-chunk.xq will be executed.
* The name of the chunk is passed to the document through the variable `$dbName`.
======================================

[[spatial-tests]]
=== Testing spatial aspects

==== Overview

The GmlGeoX extension module extends XQuery with additional capabilities:

* Spatial indexing of features
* Caching of feature geometries
* Validation of feature geometries
* Evaluation of topological predicates
//* Computation of new geometries - not included in the wiki yet

The complete documentation of the module is available in the http://interactive-instruments.github.io/etf-gmlgeox/javadoc/index.html?de/interactive_instruments/etf/bsxm/GmlGeoX.html[JavaDoc description].

==== Spatial indexing

Feature geometries can be indexed using an r*-tree. To index a feature execute `ggeo:index( Node featureNode, String id, Node xmlGeometry )`.

* 'featureNode' is the XML node with the feature to index.
* 'id' is a String id used for the geometry cache. Typically the gml:id of the feature is used.
* 'xmlGeometry' is the XML node with the GML geometry element to index.

It is essential that the XML database is not updated after this function is used
otherwise the database index structures will change and the internal cache
references will become obsolete.

.Indexing a list of features
====
To index a node list of features (`$features`) simply execute (where `ns:geometry` is the primary geometry property):

[source,XQuery]
----
let $dummy := for $feature in $features
	return ggeo:index(db:node-pre($feature),db:name($feature),$feature/@gml:id,$feature/ns:geometry/*[1])
----
====

Once the index has been established, it can be searched to find all features whose bounding box overlaps with another bounding box. The `ggeo:search( number minx, number miny, number maxx, number maxy )` function returns a node list of indexed features overlapping with the search bounding box:

.Search all indexed features in a bounding box
====
[source,XQuery]
----
let $env := ggeo:envelope($candidate_geometry)
let $overlapping_features := ggeo:search($env[1],$env[2],$env[3],$env[4])
----
====

.Select the candidate geometries that may intersect the search bounding box
====
[source,XQuery]
----
let $geometries :=
	for $feature in ggeo:search($env[1],$env[2],$env[3],$env[4])
		return ggeo:getGeometry($feature/@gml:id,$feature/ns:geometry/*[1])
----
====

==== Geometry caching

The parsed geometries are cached during indexing to avoid multiple computations of the geometries from the XML. The cache size can be set before the indexing is started using `ggeo:cacheSize( int size )`, the default size is 100000 geometries. The cache is transparent to the user of the GmlGeoX module.

Geometries are accessed from the index using `geo:getGeometry( String id, Node xmlGeometry )`. The `id` is specified during the indexing, typically the gml:id attribute of the GML feature is used. If the geometry with the id is currently in the cache, it is returned. Otherwise the geometry is computed from the XML and put into the cache.

==== Geometry Validation

Validation of GML geometry elements within a given XML node is basically a SAX-based scan for recognized GML geometry elements, and subsequent validation of these elements. The default set of recognized element names is a subset of GML. Functions offered by the module can be used to modify this set within an XQuery. See the link:https://github.com/interactive-instruments/etf-webapp/wiki/dev_manual_modules_gmlgeox[test project developer documentation for this module] for further details.

.Validation of feature geometries
====
In this XQuery expression, the feature geometries are all validated (test mask '110' means general validation and polygon patch connectivity are evaluated) and error messages returned from the GmlGeoX module are included in the test result.

[source,XQuery]
----
let $messages := for $feature in $features
  return
	try {
		let $vr := ggeo:validateAndReport($feature,'110')
		return
	   if (xs:boolean($vr/ggeo:isValid)) then ()
	   else
	   	for $message in $vr/ggeo:message[@type='ERROR']
			return
				local:addMessage('TR.invalidGeometry', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'text': $message/text() })
	} catch * {
		return () (: do not raise an error for parsing exceptions, if these are tested already elsewhere :)
	}
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count(fn:distinct-values($messages//etf:argument[@token='gmlid']/text()))),
 $messages)
----
====

==== Evaluation of topological predicates

Topological predicates between two geometries are evaluated using the JTS library. The standard predicates specified in the OGC Simple Feature standard are supported. See the link:https://github.com/interactive-instruments/etf-webapp/wiki/dev_manual_modules_gmlgeox[test project developer documentation for this module] for further details.

.Testing
====
In this XQuery expression, the feature geometries are all evaluated to determine overlaps. This assumes that all features have surface geometries.

[source,XQuery]
----
let $messages :=
(for $candidate in $features
 return
 try {
  let $candidate_geometry := ggeo:getGeometry($candidate/@gml:id,$candidate/*:geometry/*[1])
  let $env := ggeo:envelope($candidate_geometry)
  let $other_features := ggeo:search($env[1],$env[2],$env[3],$env[4])
  for $feature in $other_features[not (@gml:id = $candidate/@gml:id)]
   order by $candidate/@gml:id, $feature/@gml:id
   return
   try {
   let $other_geometry := ggeo:getGeometry($feature/@gml:id,$feature/*:geometry/*[1])
   let $check := ggeo:relate($candidate_geometry, $other_geometry, 'F********')
	return
	if ($check) then ()
	else
	let $intersection := string(ggeo:intersection($candidate_geometry, $other_geometry))
	let $polygons := functx:get-matches($intersection,'POLYGON\s?\(\s?\([\d,\.\s]+\)\s?\)')[fn:string-length(.)>0]
	return local:addMessage('TR.Overlap', map { 'filename': local:filename($candidate), 'featureType' : local-name($candidate), 'gmlid': string($candidate/@gml:id), 'gmlid2': string($feature/@gml:id), 'sharedArea': fn:string-join($polygons, ', ') })
	} catch * {
    return () (: do not raise an error for parsing exceptions, if these are tested already elsewhere :)
	}
 } catch * {
   return () (: do not raise an error for parsing exceptions, if these are tested already elsewhere :)
 }
)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count(fn:distinct-values($messages//etf:argument[@token='gmlid']/text()))),
 $messages)
----
====

////
==== Computation of new geometries

#not included yet#
////

==== Known limitations

The implementation of the GmlGeoX module depends to a large extent on the deegree framework. The default geometry implementation of deegree does not support parsing all GML types, primarily the GML 3.3 types. Also, in a number of cases spatial operations are not supported for parsed geometries. This is primarily due to the fact that deegree relies on JTS to perform these operations, and that therefore the geometries must be simplified/linearized - which is not implemented for all geometry types that can be parsed by deegree. There is even a case where an incomplete JTS representations of a deegree geometry is accepted and used for spatial operations (for a surface with multiple polygon patches only the first is used).

As a result, a test developer of this module must be very careful regarding which geometry types are supported for processing, and whether the computation is robust and exact or not. Please consult the http://interactive-instruments.github.io/etf-gmlgeox/javadoc/index.html?de/interactive_instruments/etf/bsxm/GmlGeoX.html[JavaDoc] for additional details.

For the spatial relationship operators, link:https://github.com/interactive-instruments/etf-webapp/wiki/gmlgeox-module-geometry-types-supported-by-spatial-operators[this page] in the test project developer manual documents which geometry types are supported and which are not. The page also has information, which geometry types are simplified/linearized automatically by the module.

[[parameters]]
Parameters
~~~~~~~~~~

Parameters for each Exectuable Test Suite may be declared as part of the
`etf:ExecutableTestSuite` document. The ETF web application will include
these parameters in the dialog when a test run is started.

The typical parameters for tests on sets of XML documents are:

* `files_to_test`: A regular expression. All files in the test object
where the file name matches the regular expression will be check in the
test, all other will be excluded. The default value '.*' matches all
files.
* `tests_to_execute`: A regular expression. All test assertions in the
executable test suite where the label matches the regular expression
will be used in the test run, all other will be skipped. The default
value '.*' matches all test assertions.

Here is the XML snippet for these parameters:

[source,XML]
----
    <ParameterList name="ETF Standard Parameters for XML test objects">
        <parameter name="files_to_test" required="true">
            <defaultValue>.*</defaultValue>
            <description ref="TR.filesToTest"/>
            <allowedValues>.*</allowedValues>
            <type>string</type>
        </parameter>
        <parameter name="tests_to_execute" required="false">
            <defaultValue>.*</defaultValue>
            <description ref="TR.testsToExecute"/>
            <allowedValues>.*</allowedValues>
            <type>string</type>
        </parameter>
    </ParameterList>
----

[[basex-test-object-types]]
=== Test Object Types

==== Overview

This section lists all link:#test-object-types[Test Object Types] that are pre-defined in the BaseX test driver.

For each Test Object Type, the following information is provided:

* a description
* the ID that must be used to reference the Test Object Type from an Executable Test Suite
* the parent Test Object Type in the hierarchy; for root nodes "-" is shown
* an XPath expression that can be used to detect a Test Object Type (for XML documents), if one exists

NOTE: In future versions of ETF it is planned that new Test Object Types may
be specified by a test developer defined and declared in XML in the
`include-metadata` directory.

[[tot-documents]]
==== Set of documents
A set of documents.

ID:: EIDbec4dd69-72b9-498e-a693-88e3d59d2552
Parent:: -
XPath:: -

[[tot-xml]]
==== Set of XML documents
A set of XML documents.

ID:: EID810fce18-4bf5-4c6c-a972-6962bbe3b76b
Parent:: link:#tot-documents[Set of documents]
XPath:: -

==== Metadata records
A set of XML documents. Each document contains one or more gmd:MD_Metadata elements.

ID:: EID5a60dded-0cb0-4977-9b06-16c6c2321d2e
Parent:: link:#tot-xml[Set of XML documents]
XPath:: /\*[local-name() = 'GetRecordsResponse' and starts-with(namespace-uri() = 'http://www.opengis.net/cat/csw/')] | /*[local-name() = 'MD_Metadata' and namespace-uri() = 'http://www.isotc211.org/2005/gmd']

[[tot-gml]]
==== GML feature collections
A set of XML documents. Each document contains a GML feature collection.

ID:: EIDe1d4a306-7a78-4a3b-ae2d-cf5f0810853e
Parent:: link:#tot-xml[Set of XML documents]
XPath:: -

==== WFS 2.0 feature collections
A set of XML documents. Each document contains a WFS 2.0 feature collection.

ID:: EIDa8a1b437-0ebf-454c-8204-bcf0b8548d8c
Parent:: link:#tot-gml[GML feature collections]
XPath:: /*[local-name() = 'FeatureCollection' and namespace-uri() = 'http://www.opengis.net/wfs/2.0']

==== GML 3.2 feature collections
A set of XML documents. Each document contains a GML 3.2 feature collection.

ID:: EIDc8aaacd7-df33-4d64-89af-fabeae63a958
Parent:: link:#tot-gml[GML feature collections]
XPath:: /*[local-name() = 'FeatureCollection' and namespace-uri() = 'http://www.opengis.net/gml/3.2']

==== GML 2.1/GML 3.1 feature collections
A set of XML documents. Each document contains a GML 2.1 or GML 3.1 feature collection.

ID:: EID123b2f9b-c9f4-4379-8bf1-e9a656a14bd0
Parent:: link:#tot-gml[GML feature collections]
XPath:: /*[local-name() = 'FeatureCollection' and namespace-uri() = 'http://www.opengis.net/gml']

==== INSPIRE SpatialDataSet documents
A set of XML documents. Each document contains an INSPIRE SpatialDataSet.

ID:: EID057d7919-d7b8-4d77-adb8-0d3118b3d220
Parent:: link:#tot-gml[GML feature collections]
XPath:: /*[local-name() = 'SpatialDataSet' and starts-with(namespace-uri(), 'http://inspire.ec.europa.eu/schemas/base/')]

==== CityGML 2.0 CityModel documents
A set of XML documents. Each document contains a CityGML 2.0 CityModel.

ID:: EID3e3639b1-f6b7-4d62-9160-963cfb2ea300
Parent:: link:#tot-gml[GML feature collections]
XPath:: /*[local-name() = 'CityModel' and namespace-uri() = 'http://www.opengis.net/citygml/2.0']

==== CityGML 1.0 CityModel documents
A set of XML documents. Each document contains a CityGML 1.0 CityModel.

ID:: EIDd9371e42-2bf4-420c-84a5-4ab9055a8706
Parent:: link:#tot-gml[GML feature collections]
XPath:: /*[local-name() = 'CityModel' and namespace-uri() = 'http://www.opengis.net/citygml/1.0']

[[basex-test-item-types]]
=== Test Item Types

==== Overview

This section lists all link:#test-item-types[Test Item Types] that are pre-defined in the BaseX test driver.

For each Test Item Type, the following information is provided:

* a description
* the ID that must be used to reference the Test Item Type from a test step or test assertion
* whether the type is applicable to test steps or test assertions

==== Dummy Test Step
In BaseX-based Executable Test Suites the concept of test steps is not used. A dummy test step, which is suppressed in test reports, is therefore created and associated with this test item type.

ID:: EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0
Item:: Test Step

==== XQuery
The element `etf:expression` in a test assertion contains an XQuery fragment that is executed to determine the result.

ID:: EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a
Item:: Test Assertion

==== Manual review
The element `etf:expression` in a test assertion is ignored and the assertion result status is always 'PASSED_MANUAL' indicating that a manual review from an expert is required. The review must be specified in the description of the test assertion.

ID:: EIDb48eeaa3-6a74-414a-879c-1dc708017e11
Item:: Test Assertion

==== Disabled
The element `etf:expression` in a test assertion is ignored and the assertion result status is always 'NOT_APPLICABLE'. The test assertion is disabled. This type should be used only temporarily to disable a test assertion with known issues.

ID:: EID92f22a19-2ec2-43f0-8971-c2da3eaafcd2
Item:: Test Assertion

=== Dependencies

Executable Test Suites may depend on other Executable Test Suites. This
dependency has two effects. Assume we have three test suites where test
suite A depends on test suite B which in turn depends on test suite C.

* If a user starts a test run for suite A on a set of XML documents, the
test run will first test the XML documents against test suite C, then
against test suite B and finally test suite A.
* If a test suite fails, all dependent test suites will still be executed
- in order to provide a complete picture. Otherwise a small error in a
test suite for some basic tests would block all further tests.
For example, if test suite B fails, test suite A will still be executed.
* The user will be prompted to set parameters for test suite A, which
will also be passed to test suite B and C. If test suite B or C declare
different parameters than test suite A, the default values for these
parameters will be used. Undefined parameters will be ignored.

In addition, within a test suite, dependencies may also be declared
between test cases from the same test suite. Again, dependent test cases will be skipped, if a
test case fails. With test cases dependencies, it is the responsibility
of the developers to ensure that test cases are executed in a sequence
that is consistent with the dependencies.

Here are examples how dependencies are declared in XML in an
`etf:ExecutableTestSuite` document.

.A dependency to another test suite
===========================================
[source,XML]
----
<ExecutableTestSuite ...>
  ...
  <dependencies>
    <executableTestSuite ref="EID545f9e49-009b-4114-9333-7ca26413b5d4"/>
  </dependencies>
  ...
</ExecutableTestSuite>
----
===========================================

.A dependency to another test case
===========================================
[source,XML]
----
<ExecutableTestSuite ...>
  ...
  <TestCase ...>
    ...
    <dependencies>
      <testCase ref="EID2ee0045f-cf8d-4979-9d7d-76cb465a0314"/>
    </dependencies>
    ...
  <TestCase ...>
  ...
</ExecutableTestSuite>
----
===========================================

.An INSPIRE test suite with dependencies
===========================================
The link:https://github.com/inspire-eu-validation/ets-repository/blob/master/metadata/iso/ets-md-iso-bsxets.xml[Executable Test Suite for the Conformance Class "INSPIRE Profile based on EN ISO 19115 and EN ISO 19119" in INSPIRE] includes both kinds of dependencies.
===========================================

=== Tags

To associate an Executable Test Suite with a link:#tags[tag], the tag is referenced from the XML document of the test suite.

.Associate a test suite with a tag
===========================================
The tag element in the following snippet associates the tag with `id` `EID7f57420f-b228-41ae-9467-86e7ffef6e7e` with the test suite:

[source,XML]
----
<ExecutableTestSuite ...>
  ...
  <tags>
      <tag ref="EID7f57420f-b228-41ae-9467-86e7ffef6e7e"/>
  </tags>
  ...
</ExecutableTestSuite>
----
===========================================

The tag is declared link:#tags[in XML in a separate document], in the
`include-metadata` directory.

.An INSPIRE test suite with a tag
===========================================
The link:https://github.com/inspire-eu-validation/ets-repository/blob/master/metadata/iso/ets-md-iso-bsxets.xml[Executable Test Suite for the Conformance Class "INSPIRE Profile based on EN ISO 19115 and EN ISO 19119" in INSPIRE] is associated with a  link:https://github.com/inspire-eu-validation/ets-repository/blob/master/include-metadata/Tag-EID3b9846c7-3940-4795-ae1d-0b5d82375c76.xml[tag for test suites for metadata according to version 1.3 of the INSPIRE technical guidance for metadata].
===========================================

=== Statistical information

If a test result includes an link:#basex-attachments[attachment] with the type "StatisticalReport", a statistical table is included in the test report. The root element must be an `etf:StatisticalReportTable` and all `etf:entry` elements are shown - the value before the semicolon in a column "Type" (feature type or metadata record type) and the value after the semicolon in a column "Count" (number of features or metadata records of that type).

.A sample StatisticalReportTable attachment
===========================================
[source,XML]
----
<StatisticalReportTable xmlns="http://www.interactive-instruments.de/etf/2.0">
<type ref="EID242272e0-3f0a-4e9c-9643-657c4d6d304a"/>
<entries>
<entry>all; 10</entry>
<entry>dataset; 5</entry>
<entry>service; 5</entry>
</entries>
</StatisticalReportTable>
----
===========================================

[[basex-attachments]]
=== Attachments

An Executable Test Suite may record additional information to a test
result as attachments. In the case of tests on XML documents, these are
typically the following:

* A log file that includes the information that the XQuery logs using
the log() function. If the `type` attribute is set to "LogFile", the
information will be included in the HTML test report.
* A file with statistical information of the content of the XML
documents. If the `type` attribute is set to "StatisticalReport", the
information will be included in the HTML test report.
* A file with the dynamic XQuery, which may help with debugging in case
of any errors.

Attachments are written to the temporary directory (variable `$tmpDir`)
and the links to them are included in the `etf:TestTaskResult`.

.Example how attachments are referenced in a test result
===========================================
[source,XML]
----
<attachments>
  <Attachment id="EID4c16160f-9004-467d-bf49-72b7da258eff" type="LogFile">
    <label>Log file</label>
    <encoding>UTF-8</encoding>
    <mimeType>text/plain</mimeType>
    <referencedData href="http://demo-inspire-next.etf-validator.net/etf-webapp/v2/TestTaskResults/EIDfa95b457-0d69-458f-98f3-6eae9b7f388d/Attachments/EID4c16160f-9004-467d-bf49-72b7da258eff"/>
  </Attachment>
  <Attachment id="EIDd9f69337-4ae0-4df2-a058-46b71e15135c" type="StatisticalReport">
    <label>Metadata record statistics</label>
    <encoding>UTF-8</encoding>
    <mimeType>application/xml</mimeType>
    <referencedData href="http://demo-inspire-next.etf-validator.net/etf-webapp/v2/TestTaskResults/EIDfa95b457-0d69-458f-98f3-6eae9b7f388d/Attachments/EIDd9f69337-4ae0-4df2-a058-46b71e15135c"/>
  </Attachment>
  <Attachment id="EID0fed0d42-39a3-4692-8e38-e78e2f87507a" type="Query">
    <label>XQuery executed against the dataset</label>
    <encoding>UTF-8</encoding>
    <mimeType>text/plain</mimeType>
    <referencedData href="http://demo-inspire-next.etf-validator.net/etf-webapp/v2/TestTaskResults/EIDfa95b457-0d69-458f-98f3-6eae9b7f388d/Attachments/EID0fed0d42-39a3-4692-8e38-e78e2f87507a"/>
  </Attachment>
</attachments>
----
===========================================

=== Schematron

The
link:https://github.com/interactive-instruments/etf-ets-repository/tree/master/utils[etf-ets-repository]
provides two Stylesheets for generating
link:https://github.com/interactive-instruments/etf-ets-repository/blob/master/utils/schematron_2_etf_ets.xsl[ETF Executable Test Suites]
for the BaseX test driver and for generating
link:https://github.com/interactive-instruments/etf-ets-repository/blob/master/utils/schematron_2_etf_translation_template_bundle.xsl[Translation Template Bundles]
from Schematron files.

The Stylesheets map all information that are found in the Schematron file, but
since descriptors and labels are optional in the Schematron format and may be
absent, it is recommended to manually edit the generated ETS and
add these information.

The procedure to generate the ETS and the Translation Template Bundle is
described link:https://github.com/interactive-instruments/etf-ets-repository/blob/master/utils/Readme.md#transform-a-schematron-file-to-an-etf-version-2-executable-test-suite[here].
